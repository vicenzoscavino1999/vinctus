rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==================== Helper Functions ====================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the owner of the resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    // Validate membership structure against path and auth
    function isValidMembershipCreate(groupId) {
      return request.resource.data.keys().hasAll(['groupId', 'joinedAt'])
        && request.resource.data.groupId == groupId;  // Must match path
    }
    
    // Validate like structure against path
    function isValidUserLikeCreate(postId) {
      return request.resource.data.keys().hasAll(['postId', 'createdAt'])
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // Validate post like structure against path and auth
    function isValidPostLikeCreate(postId, uid) {
      return request.resource.data.keys().hasAll(['uid', 'postId', 'createdAt'])
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // Validate group member structure against path and auth
    function isValidGroupMemberCreate(groupId, uid) {
      return request.resource.data.keys().hasAll(['uid', 'groupId', 'role', 'joinedAt'])
        && request.resource.data.uid == uid  // Must match path AND auth
        && request.resource.data.groupId == groupId  // Must match path
        && request.resource.data.role == 'member';  // Must be 'member' (no self-promotion)
    }
    
    // Prevent role escalation on update
    function cannotEscalateRole() {
      return !request.resource.data.keys().hasAny(['role'])
        || request.resource.data.role == resource.data.role;
    }
    
    // ==================== User Data Collections ====================
    
    // users/{uid}/memberships/{groupId}
    // User's joined groups (denormalized for fast reads)
    match /users/{uid}/memberships/{groupId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own memberships
      allow create: if isOwner(uid) && isValidMembershipCreate(groupId);
      allow delete: if isOwner(uid);
      
      // Update only if data doesn't change (idempotent writes)
      allow update: if isOwner(uid) 
        && request.resource.data.groupId == groupId;  // Prevent spoofing
    }
    
    // users/{uid}/likes/{postId}
    // User's liked posts (denormalized for fast reads)
    match /users/{uid}/likes/{postId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own likes
      allow create: if isOwner(uid) && isValidUserLikeCreate(postId);
      allow delete: if isOwner(uid);
      
      // Update only if data doesn't change (idempotent writes)
      allow update: if isOwner(uid)
        && request.resource.data.postId == postId;  // Prevent spoofing
    }
    
    // users/{uid}/savedPosts/{postId}
    // User's saved posts (private)
    match /users/{uid}/savedPosts/{postId} {
      // Only the user can read their own saved posts
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved posts
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Update only if postId doesn't change
      allow update: if isOwner(uid)
        && request.resource.data.postId == postId;
    }
    
    // users/{uid}/savedCategories/{categoryId}
    // User's saved categories (private)
    match /users/{uid}/savedCategories/{categoryId} {
      // Only the user can read their own saved categories
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved categories
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Update only if categoryId doesn't change
      allow update: if isOwner(uid)
        && request.resource.data.categoryId == categoryId;
    }
    
    // ==================== Groups Collections ====================
    
    // groups/{groupId}
    // Group metadata (PUBLIC READ, admin write)
    match /groups/{groupId} {
      // Anyone can read groups (even anonymous users for discovery)
      allow read: if true;
      
      // For now, no one can create/update/delete groups
      // TODO: Add admin-only write when admin system is implemented
      allow write: if false;
    }
    
    // groups/{groupId}/members/{uid}
    // Group members (source of truth for counting)
    match /groups/{groupId}/members/{uid} {
      // Anyone can read members (public for member counts)
      allow read: if true;
      
      // Only the user can add/remove themselves as a member
      // Critical: Validate against BOTH path and auth
      allow create: if isOwner(uid) 
        && isValidGroupMemberCreate(groupId, uid)
        && request.resource.data.uid == request.auth.uid;  // Triple check
      
      allow delete: if isOwner(uid);
      
      // Update ONLY if critical fields don't change AND no role escalation
      allow update: if isOwner(uid)
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.uid == request.auth.uid  // Must match auth
        && request.resource.data.groupId == groupId  // Must match path
        && cannotEscalateRole();  // Cannot change role
    }
    
    // ==================== Posts Collections ====================
    
    // posts/{postId}
    // Post metadata (PUBLIC READ, author write)
    match /posts/{postId} {
      // Anyone can read posts (even anonymous for discovery)
      allow read: if true;
      
      // For now, no one can create/update/delete posts
      // TODO: Add author-only write when posts system is implemented
      allow write: if false;
    }
    
    // posts/{postId}/likes/{uid}
    // Post likes (source of truth for counting)
    match /posts/{postId}/likes/{uid} {
      // Anyone can read likes (public for like counts)
      allow read: if true;
      
      // Only the user can like/unlike
      // Critical: Validate against BOTH path and auth
      allow create: if isOwner(uid) 
        && isValidPostLikeCreate(postId, uid)
        && request.resource.data.uid == request.auth.uid;  // Triple check
      
      allow delete: if isOwner(uid);
      
      // Update ONLY if critical fields don't change
      allow update: if isOwner(uid)
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.uid == request.auth.uid  // Must match auth
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // ==================== Messaging Collections ====================
    
    // Helper: Check if user can access conversation
    function canAccessConversation(conversationId) {
      let conv = get(/databases/$(database)/documents/conversations/$(conversationId));
      return conv.data.type == "direct"
        ? exists(/databases/$(database)/documents/conversations/$(conversationId)/members/$(request.auth.uid))
        : exists(/databases/$(database)/documents/groups/$(conv.data.groupId)/members/$(request.auth.uid));
    }
    
    // conversations/{conversationId}
    match /conversations/{conversationId} {
      allow read: if isAuthenticated() && canAccessConversation(conversationId);
      
      // Restrict creation (no spam conversations)
      allow create: if isAuthenticated()
        && request.resource.data.type in ['direct', 'group']
        && (request.resource.data.type == 'direct' 
            || (request.resource.data.type == 'group' 
                && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid))));
      
      allow update: if isAuthenticated() && canAccessConversation(conversationId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'updatedAt']);
      
      // Members (restrict updates)
      match /members/{uid} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow create: if isAuthenticated() && request.auth.uid == uid;
        allow update: if isAuthenticated() 
          && request.auth.uid == uid
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastReadClientAt', 'lastReadAt', 'muted'])
          && request.resource.data.role == resource.data.role;  // No self-promotion
        allow delete: if isAuthenticated() && request.auth.uid == uid;
      }
      
      // Messages
      match /messages/{messageId} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow create: if isAuthenticated() 
          && canAccessConversation(conversationId)
          && request.resource.data.senderId == request.auth.uid;
      }
      
      // Typing
      match /typing/{uid} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow write: if isAuthenticated() 
          && request.auth.uid == uid
          && canAccessConversation(conversationId);
      }
    }
    
    // ==================== Default Deny ====================
    
    // Deny all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
