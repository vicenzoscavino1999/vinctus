rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==================== Helper Functions ====================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the owner of the resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    // Validate membership structure against path and auth
    function isValidMembershipCreate(groupId) {
      return request.resource.data.keys().hasAll(['groupId', 'joinedAt'])
        && request.resource.data.groupId == groupId;  // Must match path
    }
    
    // Validate like structure against path
    function isValidUserLikeCreate(postId) {
      return request.resource.data.keys().hasAll(['postId', 'createdAt'])
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // Validate post like structure against path and auth
    function isValidPostLikeCreate(postId, uid) {
      return request.resource.data.keys().hasAll(['uid', 'postId', 'createdAt'])
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // Validate group member structure against path and auth
    function isValidGroupMemberCreate(groupId, uid) {
      return request.resource.data.keys().hasAll(['uid', 'groupId', 'role', 'joinedAt'])
        && request.resource.data.uid == uid  // Must match path AND auth
        && request.resource.data.groupId == groupId  // Must match path
        && request.resource.data.role == 'member';  // Must be 'member' (no self-promotion)
    }
    
    // Prevent role escalation on update
    function cannotEscalateRole() {
      return !request.resource.data.keys().hasAny(['role'])
        || request.resource.data.role == resource.data.role;
    }
    
    // ==================== User Data Collections ====================

    // users/{uid}
    // User profile document
    match /users/{uid} {
      allow read: if isOwner(uid);
      allow create, update, delete: if isOwner(uid);
    }

    // users_public/{uid}
    // Public user profile for search
    match /users_public/{uid} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isOwner(uid);
    }

    // friend_requests/{requestId}
    // Friend request system
    match /friend_requests/{requestId} {
      // Users can read requests they sent or received
      allow read: if isAuthenticated() 
        && (resource.data.fromUid == request.auth.uid || resource.data.toUid == request.auth.uid);
      
      // Users can create requests where they are the sender
      allow create: if isAuthenticated()
        && request.resource.data.fromUid == request.auth.uid
        && request.resource.data.toUid != request.auth.uid
        && request.resource.data.keys().hasAll(['fromUid', 'toUid', 'status', 'createdAt', 'updatedAt'])
        && request.resource.data.status == 'pending';
      
      // Sender can update to re-send (if rejected), receiver can accept/reject
      allow update: if isAuthenticated()
        && (
          // Sender can update status back to pending (re-send after rejection)
          (resource.data.fromUid == request.auth.uid && request.resource.data.status == 'pending')
          ||
          // Receiver can accept or reject
          (resource.data.toUid == request.auth.uid && request.resource.data.status in ['accepted', 'rejected'])
        );
      
      // Sender can delete (cancel) their request
      allow delete: if isAuthenticated() && resource.data.fromUid == request.auth.uid;
    }
    
    // users/{uid}/memberships/{groupId}
    // User's joined groups (denormalized for fast reads)
    match /users/{uid}/memberships/{groupId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own memberships
      allow create: if isOwner(uid) && isValidMembershipCreate(groupId);
      allow delete: if isOwner(uid);
      
      // Update only if data doesn't change (idempotent writes)
      allow update: if isOwner(uid) 
        && request.resource.data.groupId == groupId;  // Prevent spoofing
    }
    
    // users/{uid}/likes/{postId}
    // User's liked posts (denormalized for fast reads)
    match /users/{uid}/likes/{postId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own likes
      allow create: if isOwner(uid) && isValidUserLikeCreate(postId);
      allow delete: if isOwner(uid);
      
      // Update only if data doesn't change (idempotent writes)
      allow update: if isOwner(uid)
        && request.resource.data.postId == postId;  // Prevent spoofing
    }
    
    // users/{uid}/savedPosts/{postId}
    // User's saved posts (private)
    match /users/{uid}/savedPosts/{postId} {
      // Only the user can read their own saved posts
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved posts
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Update only if postId doesn't change
      allow update: if isOwner(uid)
        && request.resource.data.postId == postId;
    }
    
    // users/{uid}/savedCategories/{categoryId}
    // User's saved categories (private)
    match /users/{uid}/savedCategories/{categoryId} {
      // Only the user can read their own saved categories
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved categories
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Update only if categoryId doesn't change
      allow update: if isOwner(uid)
        && request.resource.data.categoryId == categoryId;
    }
    
    // ==================== Groups Collections ====================
    
    // groups/{groupId}
    // Group metadata (PUBLIC READ, admin write)
    match /groups/{groupId} {
      // Anyone can read groups (even anonymous users for discovery)
      allow read: if true;
      
      // For now, no one can create/update/delete groups
      // TODO: Add admin-only write when admin system is implemented
      allow write: if false;
    }
    
    // groups/{groupId}/members/{uid}
    // Group members (source of truth for counting)
    match /groups/{groupId}/members/{uid} {
      // Only the member can read their own membership (private)
      allow read: if isOwner(uid);
      
      // Only the user can add/remove themselves as a member
      // Critical: Validate against BOTH path and auth
      allow create: if isOwner(uid) 
        && isValidGroupMemberCreate(groupId, uid)
        && request.resource.data.uid == request.auth.uid;  // Triple check
      
      allow delete: if isOwner(uid);
      
      // Update ONLY if critical fields don't change AND no role escalation
      allow update: if isOwner(uid)
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.uid == request.auth.uid  // Must match auth
        && request.resource.data.groupId == groupId  // Must match path
        && cannotEscalateRole();  // Cannot change role
    }
    
    // ==================== Posts Collections ====================
    
    // ==================== Post Validation Functions ====================
    
    // Validate author fields match the user's actual profile (NULL SAFE)
    function isValidAuthorInfo() {
      let profileDoc = get(/databases/$(database)/documents/users_public/$(request.auth.uid));
      let data = request.resource.data;
      
      // Profile document must exist and have valid fields
      return profileDoc != null
        && profileDoc.data != null
        && profileDoc.data.displayName is string
        && profileDoc.data.displayName.size() > 0
        && profileDoc.data.username is string
        && profileDoc.data.username.size() > 0
        && data.authorId == request.auth.uid
        && data.authorName == profileDoc.data.displayName
        && data.authorUsername == profileDoc.data.username
        && (data.authorPhoto == profileDoc.data.photoURL || data.authorPhoto == null);
    }

    // Validate author snapshot for uploading workflow
    function isValidAuthorSnapshot() {
      let data = request.resource.data;
      return data.authorId == request.auth.uid
        && data.authorSnapshot is map
        && data.authorSnapshot.keys().hasOnly(['displayName', 'photoURL'])
        && data.authorSnapshot.displayName is string
        && data.authorSnapshot.displayName.size() > 0
        && (data.authorSnapshot.photoURL == null || data.authorSnapshot.photoURL is string);
    }
    
    // Validate a single media item with postId binding
    function isValidMediaItem(item, postId) {
      // Image: path must be images/
      let isImage = item.type == 'image'
        && item.path.matches('posts/' + request.auth.uid + '/' + postId + '/images/[^/]+');
      
      // Video: path must be videos/
      let isVideo = item.type == 'video'
        && item.path.matches('posts/' + request.auth.uid + '/' + postId + '/videos/[^/]+');

      // contentType is optional; if present, it must match type
      let hasContentType = item.keys().hasAny(['contentType']);
      let validContentType = !hasContentType
        || (item.contentType is string
          && item.contentType.size() <= 50
          && ((isImage && item.contentType.matches('image/.*'))
              || (isVideo && item.contentType.matches('video/.*'))));
      
      return item.keys().hasOnly(['url', 'path', 'type', 'contentType', 'width', 'height'])
        && item.url is string
        && item.url.size() > 0
        && item.url.size() <= 500
        && item.path is string
        && item.path.size() <= 300
        && item.type in ['image', 'video']
        && (isImage || isVideo)
        && validContentType;
    }
    
    // Validate all media items in the array (no nulls allowed)
    function isValidMediaArray(media, postId) {
      return media.size() >= 0
        && media.size() <= 10
        && (media.size() == 0 || isValidMediaItem(media[0], postId))
        && (media.size() <= 1 || isValidMediaItem(media[1], postId))
        && (media.size() <= 2 || isValidMediaItem(media[2], postId))
        && (media.size() <= 3 || isValidMediaItem(media[3], postId))
        && (media.size() <= 4 || isValidMediaItem(media[4], postId))
        && (media.size() <= 5 || isValidMediaItem(media[5], postId))
        && (media.size() <= 6 || isValidMediaItem(media[6], postId))
        && (media.size() <= 7 || isValidMediaItem(media[7], postId))
        && (media.size() <= 8 || isValidMediaItem(media[8], postId))
        && (media.size() <= 9 || isValidMediaItem(media[9], postId));
    }
    
    // Validate post structure on create
    function isValidPostCreate(postId) {
      let data = request.resource.data;
      return data.keys().hasOnly(['authorId', 'authorName', 'authorUsername', 'authorPhoto', 'content', 'media', 'groupId', 'categoryId', 'likeCount', 'commentCount', 'createdAt', 'updatedAt'])
        && isValidAuthorInfo()
        && data.content is string
        && data.content.size() > 0
        && data.content.size() <= 5000
        && data.media is list
        && isValidMediaArray(data.media, postId)
        && (data.groupId == null || (data.groupId is string && data.groupId.size() <= 100))
        && (data.categoryId == null || (data.categoryId is string && data.categoryId.size() <= 100))
        && data.likeCount is int
        && data.likeCount == 0
        && data.commentCount is int
        && data.commentCount == 0
        && data.createdAt == request.time
        && data.updatedAt == null;
    }

    // Validate post structure on create (uploading workflow)
    function isValidPostCreateUploading(postId) {
      let data = request.resource.data;
      return data.keys().hasOnly(['postId', 'authorId', 'authorSnapshot', 'text', 'media', 'status', 'createdAt', 'updatedAt'])
        && data.postId == postId
        && isValidAuthorSnapshot()
        && data.text is string
        && data.text.size() > 0
        && data.text.size() <= 5000
        && data.media is list
        && data.media.size() == 0
        && data.status == 'uploading'
        && data.createdAt == request.time
        && data.updatedAt == null;
    }
    
    // Validate post update (only content and media can change)
    function isValidPostUpdate(postId) {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['content', 'media', 'updatedAt'])
        && request.resource.data.content is string
        && request.resource.data.content.size() > 0
        && request.resource.data.content.size() <= 5000
        && request.resource.data.media is list
        && isValidMediaArray(request.resource.data.media, postId)
        && request.resource.data.updatedAt == request.time;
    }

    // Validate post update (uploading workflow)
    function isValidPostUpdateUploading(postId) {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['status', 'media', 'updatedAt'])
        && request.resource.data.status in ['ready', 'failed']
        && request.resource.data.media is list
        && isValidMediaArray(request.resource.data.media, postId)
        && request.resource.data.updatedAt == request.time;
    }
    
    // Check if user is the post author
    function isPostAuthor() {
      return resource.data.authorId == request.auth.uid;
    }
    
    // posts/{postId}
    // Post metadata (PUBLIC READ, author write)
    match /posts/{postId} {
      // Anyone can read posts (even anonymous for discovery)
      allow read: if true;
      
      // Only authenticated users can create posts with valid author info
      allow create: if isAuthenticated()
        && (isValidPostCreate(postId) || isValidPostCreateUploading(postId));
      
      // Only the author can update their posts
      allow update: if isAuthenticated() && isPostAuthor()
        && (isValidPostUpdate(postId) || isValidPostUpdateUploading(postId));
      
      // Only the author can delete their posts
      allow delete: if isAuthenticated() && isPostAuthor();
    }
    
    // posts/{postId}/likes/{uid}
    // Post likes (source of truth for counting)
    match /posts/{postId}/likes/{uid} {
      // Only the user can read their own like (private)
      allow read: if isOwner(uid);
      
      // Only the user can like/unlike
      // Critical: Validate against BOTH path and auth
      allow create: if isOwner(uid) 
        && isValidPostLikeCreate(postId, uid)
        && request.resource.data.uid == request.auth.uid;  // Triple check
      
      allow delete: if isOwner(uid);
      
      // Update ONLY if critical fields don't change
      allow update: if isOwner(uid)
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.uid == request.auth.uid  // Must match auth
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // ==================== Messaging Collections ====================
    
    // Helper: Check if user can access conversation
    function isDirectConversationMember(conv, uid) {
      return conv.data.type == "direct"
        && conv.data.memberIds is list
        && conv.data.memberIds.hasAny([uid]);
    }
    
    function isGroupConversationMember(conv, uid) {
      return conv.data.type == "group"
        && conv.data.groupId is string
        && exists(/databases/$(database)/documents/groups/$(conv.data.groupId)/members/$(uid));
    }
    
    function isConversationParticipant(conversationId, uid) {
      let conv = get(/databases/$(database)/documents/conversations/$(conversationId));
      return conv.data != null
        && (isDirectConversationMember(conv, uid) || isGroupConversationMember(conv, uid));
    }
    
    function canAccessConversation(conversationId) {
      return isAuthenticated()
        && isConversationParticipant(conversationId, request.auth.uid);
    }
    
    function canCreateConversationMember(conversationId, uid) {
      let conv = get(/databases/$(database)/documents/conversations/$(conversationId));
      return conv.data != null
        && (conv.data.type == "direct"
          ? conv.data.memberIds is list
            && conv.data.memberIds.hasAny([request.auth.uid])
            && conv.data.memberIds.hasAny([uid])
          : conv.data.type == "group"
            && conv.data.groupId is string
            && request.auth.uid == uid
            && exists(/databases/$(database)/documents/groups/$(conv.data.groupId)/members/$(uid)));
    }
    
    function isValidConversationMemberCreate(uid) {
      return request.resource.data.keys().hasAll(['uid', 'role', 'joinedAt', 'lastReadClientAt', 'lastReadAt', 'muted'])
        && request.resource.data.uid == uid
        && request.resource.data.role == 'member';
    }
    
    // conversations/{conversationId}
    match /conversations/{conversationId} {
      allow read: if isAuthenticated() && canAccessConversation(conversationId);
      
      // Restrict creation (no spam conversations)
      allow create: if isAuthenticated()
        && request.resource.data.type in ['direct', 'group']
        && (request.resource.data.type == 'direct' 
            ? request.resource.data.memberIds is list
              && request.resource.data.memberIds.size() == 2
              && request.resource.data.memberIds.hasAny([request.auth.uid])
            : request.resource.data.type == 'group' 
              && request.resource.data.groupId is string
              && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid)));
      
      allow update: if isAuthenticated() && canAccessConversation(conversationId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'updatedAt']);
      
      // Members (restrict updates)
      match /members/{uid} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow create: if isAuthenticated()
          && canCreateConversationMember(conversationId, uid)
          && isValidConversationMemberCreate(uid);
        allow update: if isAuthenticated() 
          && request.auth.uid == uid
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastReadClientAt', 'lastReadAt', 'muted'])
          && request.resource.data.role == resource.data.role;  // No self-promotion
        allow delete: if isAuthenticated() && request.auth.uid == uid;
      }
      
      // Messages
      match /messages/{messageId} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow create: if isAuthenticated() 
          && canAccessConversation(conversationId)
          && request.resource.data.senderId == request.auth.uid;
      }
      
      // Typing
      match /typing/{uid} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow write: if isAuthenticated() 
          && request.auth.uid == uid
          && canAccessConversation(conversationId);
      }
    }
    
    // ==================== Default Deny ====================
    
    // Deny all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
