rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==================== Helper Functions ====================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the owner of the resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    // Validate membership structure against path and auth
    function isValidMembershipCreate(groupId) {
      return request.resource.data.keys().hasAll(['groupId', 'joinedAt'])
        && request.resource.data.groupId == groupId;  // Must match path
    }
    
    // Validate like structure against path
    function isValidUserLikeCreate(postId) {
      return request.resource.data.keys().hasAll(['postId', 'createdAt'])
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // Validate post like structure against path and auth
    function isValidPostLikeCreate(postId, uid) {
      return request.resource.data.keys().hasAll(['uid', 'postId', 'createdAt'])
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.postId == postId;  // Must match path
    }
    
    // Validate group member structure against path and auth
    function isValidGroupMemberCreate(groupId, uid) {
      return request.resource.data.keys().hasAll(['uid', 'groupId', 'role', 'joinedAt'])
        && request.resource.data.uid == uid  // Must match path AND auth
        && request.resource.data.groupId == groupId  // Must match path
        && request.resource.data.role in ['member', 'moderator', 'admin'];
    }
    
    // Prevent role escalation on update
    function cannotEscalateRole() {
      return !request.resource.data.keys().hasAny(['role'])
        || request.resource.data.role == resource.data.role;
    }

    function getGroupDoc(groupId) {
      return get(/databases/$(database)/documents/groups/$(groupId));
    }

    function canCreateMembershipForUser(uid, groupId) {
      let group = getGroupDoc(groupId);
      return group != null && group.data != null && group.data.ownerId == request.auth.uid;
    }
    
    // ==================== User Data Collections ====================

    // users/{uid}
    // User profile document
    match /users/{uid} {
      allow read: if isOwner(uid);
      allow create, update, delete: if isOwner(uid);
    }

    // users_public/{uid}
    // Public user profile for search
    match /users_public/{uid} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isOwner(uid);
    }

    // friend_requests/{requestId}
    // Friend request system
    match /friend_requests/{requestId} {
      // Users can read requests they sent or received
      allow read: if isAuthenticated() 
        && (resource.data.fromUid == request.auth.uid || resource.data.toUid == request.auth.uid);
      
      // Users can create requests where they are the sender
      allow create: if isAuthenticated()
        && request.resource.data.fromUid == request.auth.uid
        && request.resource.data.toUid != request.auth.uid
        && request.resource.data.keys().hasAll(['fromUid', 'toUid', 'status', 'createdAt', 'updatedAt'])
        && request.resource.data.status == 'pending';
      
      // Sender can update to re-send (if rejected), receiver can accept/reject
      allow update: if isAuthenticated()
        && (
          // Sender can update status back to pending (re-send after rejection)
          (resource.data.fromUid == request.auth.uid && request.resource.data.status == 'pending')
          ||
          // Receiver can accept or reject
          (resource.data.toUid == request.auth.uid && request.resource.data.status in ['accepted', 'rejected'])
        );
      
      // Sender can delete (cancel) their request
      allow delete: if isAuthenticated() && resource.data.fromUid == request.auth.uid;
    }
    
    // users/{uid}/memberships/{groupId}
    // User's joined groups (denormalized for fast reads)
    match /users/{uid}/memberships/{groupId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own memberships
      allow create: if (isOwner(uid) || canCreateMembershipForUser(uid, groupId))
        && isValidMembershipCreate(groupId);
      allow delete: if isOwner(uid) || canCreateMembershipForUser(uid, groupId);
      
      // Update only if data doesn't change (idempotent writes)
      allow update: if isOwner(uid) 
        && request.resource.data.groupId == groupId;  // Prevent spoofing
    }
    
    // users/{uid}/likes/{postId}
    // User's liked posts (denormalized for fast reads)
    match /users/{uid}/likes/{postId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own likes
      allow create: if isOwner(uid) && isValidUserLikeCreate(postId);
      allow delete: if isOwner(uid);
      
      // Update only if data doesn't change (idempotent writes)
      allow update: if isOwner(uid)
        && request.resource.data.postId == postId;  // Prevent spoofing
    }
    
    // users/{uid}/savedPosts/{postId}
    // User's saved posts (private)
    match /users/{uid}/savedPosts/{postId} {
      // Only the user can read their own saved posts
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved posts
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Update only if postId doesn't change
      allow update: if isOwner(uid)
        && request.resource.data.postId == postId;
    }
    
    // users/{uid}/savedCategories/{categoryId}
    // User's saved categories (private)
    match /users/{uid}/savedCategories/{categoryId} {
      // Only the user can read their own saved categories
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved categories
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Update only if categoryId doesn't change
      allow update: if isOwner(uid)
        && request.resource.data.categoryId == categoryId;
    }
    
    // ==================== Groups Collections ====================

    function isGroupOwner(groupId) {
      let group = getGroupDoc(groupId);
      return group != null && group.data != null && group.data.ownerId == request.auth.uid;
    }

    function isGroupPublic(groupId) {
      let group = getGroupDoc(groupId);
      return group != null && group.data != null && group.data.visibility == 'public';
    }

    function isValidGroupCreate() {
      let data = request.resource.data;
      let hasIcon = data.keys().hasAny(['iconUrl']);
      let hasCategory = data.keys().hasAny(['categoryId']);
      let hasMemberCount = data.keys().hasAny(['memberCount']);

      return data.keys().hasOnly([
          'name', 'description', 'categoryId', 'visibility', 'ownerId', 'iconUrl',
          'memberCount', 'createdAt', 'updatedAt'
        ])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 80
        && data.description is string
        && data.description.size() > 0
        && data.description.size() <= 600
        && data.visibility in ['public', 'private']
        && data.ownerId == request.auth.uid
        && (!hasCategory || data.categoryId == null || (data.categoryId is string && data.categoryId.size() > 0 && data.categoryId.size() <= 80))
        && (!hasIcon || data.iconUrl == null || (data.iconUrl is string && data.iconUrl.size() > 0 && data.iconUrl.size() <= 500))
        && (!hasMemberCount || (data.memberCount is int && data.memberCount >= 1))
        && data.createdAt == request.time
        && data.updatedAt == request.time;
    }

    function isValidGroupUpdate() {
      let data = request.resource.data;
      let changed = data.diff(resource.data).affectedKeys();
      let hasIcon = data.keys().hasAny(['iconUrl']);
      let hasCategory = data.keys().hasAny(['categoryId']);
      let hasMemberCount = data.keys().hasAny(['memberCount']);

      return changed.hasOnly([
          'name', 'description', 'categoryId', 'visibility', 'iconUrl', 'memberCount', 'updatedAt'
        ])
        && data.ownerId == resource.data.ownerId
        && data.createdAt == resource.data.createdAt
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 80
        && data.description is string
        && data.description.size() > 0
        && data.description.size() <= 600
        && data.visibility in ['public', 'private']
        && (!hasCategory || data.categoryId == null || (data.categoryId is string && data.categoryId.size() > 0 && data.categoryId.size() <= 80))
        && (!hasIcon || data.iconUrl == null || (data.iconUrl is string && data.iconUrl.size() > 0 && data.iconUrl.size() <= 500))
        && (!hasMemberCount || (data.memberCount is int && data.memberCount >= 1))
        && data.updatedAt == request.time;
    }

    function isValidGroupMemberSelfCreate(groupId, uid) {
      return isValidGroupMemberCreate(groupId, uid)
        && request.auth.uid == uid
        && request.resource.data.role == 'member'
        && isGroupPublic(groupId);
    }

    function isValidGroupMemberOwnerCreate(groupId, uid) {
      return isValidGroupMemberCreate(groupId, uid)
        && isGroupOwner(groupId)
        && request.resource.data.role in ['member', 'moderator', 'admin'];
    }

    function isValidGroupMemberRoleUpdate(groupId, uid) {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['role'])
        && request.resource.data.uid == uid
        && request.resource.data.groupId == groupId
        && request.resource.data.role in ['member', 'moderator', 'admin'];
    }

    function isValidGroupJoinRequestCreate() {
      let data = request.resource.data;
      let group = getGroupDoc(data.groupId);
      return data.keys().hasOnly([
          'groupId', 'groupName', 'fromUid', 'toUid', 'status', 'message',
          'fromUserName', 'fromUserPhoto', 'createdAt', 'updatedAt'
        ])
        && data.groupId is string
        && data.groupId.size() > 0
        && data.groupName is string
        && data.groupName.size() > 0
        && data.groupName.size() <= 120
        && data.fromUid == request.auth.uid
        && data.toUid is string
        && data.toUid.size() > 0
        && data.toUid != request.auth.uid
        && data.status == 'pending'
        && (data.message == null || (data.message is string && data.message.size() > 0 && data.message.size() <= 1000))
        && (data.fromUserName == null || (data.fromUserName is string && data.fromUserName.size() > 0 && data.fromUserName.size() <= 80))
        && (data.fromUserPhoto == null || data.fromUserPhoto is string)
        && data.createdAt == request.time
        && data.updatedAt == request.time
        && group != null
        && group.data != null
        && group.data.ownerId == data.toUid
        && group.data.visibility == 'private';
    }

    function isValidGroupJoinRequestUpdate() {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['status', 'updatedAt'])
        && request.resource.data.status in ['accepted', 'rejected']
        && request.resource.data.updatedAt == request.time
        && request.resource.data.fromUid == resource.data.fromUid
        && request.resource.data.toUid == resource.data.toUid
        && request.resource.data.groupId == resource.data.groupId
        && request.resource.data.groupName == resource.data.groupName;
    }
    
    // groups/{groupId}
    // Group metadata (PUBLIC READ, owner write)
    match /groups/{groupId} {
      // Anyone can read groups (even anonymous users for discovery)
      allow read: if true;
      
      allow create: if isAuthenticated() && isValidGroupCreate();
      allow update: if isAuthenticated() && resource.data.ownerId == request.auth.uid
        && isValidGroupUpdate();
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }
    
    // groups/{groupId}/members/{uid}
    // Group members (source of truth for counting)
    match /groups/{groupId}/members/{uid} {
      // Allow authenticated reads for member display
      allow read: if isAuthenticated();
      
      // Self-join for public groups OR owner adds member (private/public)
      allow create: if isAuthenticated()
        && (isValidGroupMemberSelfCreate(groupId, uid) || isValidGroupMemberOwnerCreate(groupId, uid));
      
      allow delete: if isOwner(uid) || isGroupOwner(groupId);
      
      // Owner can adjust roles
      allow update: if isGroupOwner(groupId)
        && isValidGroupMemberRoleUpdate(groupId, uid);
    }

    // group_requests/{requestId}
    // Requests to join private groups
    match /group_requests/{requestId} {
      allow read: if isAuthenticated()
        && (resource.data.fromUid == request.auth.uid || resource.data.toUid == request.auth.uid);
      allow create: if isAuthenticated() && isValidGroupJoinRequestCreate();
      allow update: if isAuthenticated() && resource.data.toUid == request.auth.uid
        && isValidGroupJoinRequestUpdate();
      allow delete: if isAuthenticated() && resource.data.fromUid == request.auth.uid;
    }
    
    // ==================== Posts Collections ====================
    
    // ==================== Post Validation Functions ====================
    
    // Validate author fields match the user's actual profile (NULL SAFE)
    function isValidAuthorInfo() {
      let profileDoc = get(/databases/$(database)/documents/users_public/$(request.auth.uid));
      let data = request.resource.data;
      
      // Profile document must exist and have valid fields
      return profileDoc != null
        && profileDoc.data != null
        && profileDoc.data.displayName is string
        && profileDoc.data.displayName.size() > 0
        && profileDoc.data.username is string
        && profileDoc.data.username.size() > 0
        && data.authorId == request.auth.uid
        && data.authorName == profileDoc.data.displayName
        && data.authorUsername == profileDoc.data.username
        && (data.authorPhoto == profileDoc.data.photoURL || data.authorPhoto == null);
    }

    // Validate author snapshot for uploading workflow
    function isValidAuthorSnapshot() {
      let data = request.resource.data;
      return data.authorId == request.auth.uid
        && data.authorSnapshot is map
        && data.authorSnapshot.keys().hasOnly(['displayName', 'photoURL'])
        && data.authorSnapshot.displayName is string
        && data.authorSnapshot.displayName.size() > 0
        && (data.authorSnapshot.photoURL == null || data.authorSnapshot.photoURL is string);
    }
    
    // Validate a single media item with postId binding
    function isValidMediaItem(item, postId) {
      // Image: path must be images/
      let isImage = item.type == 'image'
        && item.path.matches('posts/' + request.auth.uid + '/' + postId + '/images/[^/]+');
      
      // Video: path must be videos/
      let isVideo = item.type == 'video'
        && item.path.matches('posts/' + request.auth.uid + '/' + postId + '/videos/[^/]+');

      // contentType is optional; if present, it must match type
      let hasContentType = item.keys().hasAny(['contentType']);
      let validContentType = !hasContentType
        || (item.contentType is string
          && item.contentType.size() <= 50
          && ((isImage && item.contentType.matches('image/.*'))
              || (isVideo && item.contentType.matches('video/.*'))));
      
      return item.keys().hasOnly(['url', 'path', 'type', 'contentType', 'width', 'height'])
        && item.url is string
        && item.url.size() > 0
        && item.url.size() <= 500
        && item.path is string
        && item.path.size() <= 300
        && item.type in ['image', 'video']
        && (isImage || isVideo)
        && validContentType;
    }
    
    // Validate all media items in the array (no nulls allowed)
    function isValidMediaArray(media, postId) {
      return media.size() >= 0
        && media.size() <= 10
        && (media.size() == 0 || isValidMediaItem(media[0], postId))
        && (media.size() <= 1 || isValidMediaItem(media[1], postId))
        && (media.size() <= 2 || isValidMediaItem(media[2], postId))
        && (media.size() <= 3 || isValidMediaItem(media[3], postId))
        && (media.size() <= 4 || isValidMediaItem(media[4], postId))
        && (media.size() <= 5 || isValidMediaItem(media[5], postId))
        && (media.size() <= 6 || isValidMediaItem(media[6], postId))
        && (media.size() <= 7 || isValidMediaItem(media[7], postId))
        && (media.size() <= 8 || isValidMediaItem(media[8], postId))
        && (media.size() <= 9 || isValidMediaItem(media[9], postId));
    }
    
    // Validate post structure on create
    function isValidPostCreate(postId) {
      let data = request.resource.data;
      return data.keys().hasOnly(['authorId', 'authorName', 'authorUsername', 'authorPhoto', 'content', 'media', 'groupId', 'categoryId', 'likeCount', 'commentCount', 'createdAt', 'updatedAt'])
        && isValidAuthorInfo()
        && data.content is string
        && data.content.size() > 0
        && data.content.size() <= 5000
        && data.media is list
        && isValidMediaArray(data.media, postId)
        && (data.groupId == null || (data.groupId is string && data.groupId.size() <= 100))
        && (data.categoryId == null || (data.categoryId is string && data.categoryId.size() <= 100))
        && data.likeCount is int
        && data.likeCount == 0
        && data.commentCount is int
        && data.commentCount == 0
        && data.createdAt == request.time
        && data.updatedAt == null;
    }

    // Validate post structure on create (uploading workflow)
    function isValidPostCreateUploading(postId) {
      let data = request.resource.data;
      return data.keys().hasOnly([
          'postId', 'authorId', 'authorSnapshot', 'text', 'media', 'status', 'createdAt', 'updatedAt',
          'content', 'authorName', 'authorUsername', 'authorPhoto', 'groupId', 'categoryId', 'likeCount', 'commentCount'
        ])
        && data.postId == postId
        && isValidAuthorSnapshot()
        && data.text is string
        && data.text.size() > 0
        && data.text.size() <= 5000
        && data.media is list
        && data.media.size() == 0
        && data.status == 'uploading'
        && data.createdAt == request.time
        && data.updatedAt == null
        && (!data.keys().hasAny(['content']) || (data.content is string && data.content.size() > 0 && data.content.size() <= 5000 && data.content == data.text))
        && (!data.keys().hasAny(['authorName']) || (data.authorName is string && data.authorName.size() > 0))
        && (!data.keys().hasAny(['authorUsername']) || (data.authorUsername is string && data.authorUsername.size() > 0))
        && (!data.keys().hasAny(['authorPhoto']) || (data.authorPhoto == null || data.authorPhoto is string))
        && (!data.keys().hasAny(['groupId']) || (data.groupId == null || (data.groupId is string && data.groupId.size() <= 100)))
        && (!data.keys().hasAny(['categoryId']) || (data.categoryId == null || (data.categoryId is string && data.categoryId.size() <= 100)))
        && (!data.keys().hasAny(['likeCount']) || (data.likeCount is int && data.likeCount == 0))
        && (!data.keys().hasAny(['commentCount']) || (data.commentCount is int && data.commentCount == 0));
    }
    
    // Validate post update (only content and media can change)
    function isValidPostUpdate(postId) {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['content', 'media', 'updatedAt'])
        && request.resource.data.content is string
        && request.resource.data.content.size() > 0
        && request.resource.data.content.size() <= 5000
        && request.resource.data.media is list
        && isValidMediaArray(request.resource.data.media, postId)
        && request.resource.data.updatedAt == request.time;
    }

    // Validate post update (uploading workflow)
    function isValidPostUpdateUploading(postId) {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['status', 'media', 'updatedAt'])
        && request.resource.data.status in ['ready', 'failed']
        && request.resource.data.media is list
        && isValidMediaArray(request.resource.data.media, postId)
        && request.resource.data.updatedAt == request.time;
    }

    // Validate comment create
    function isValidPostCommentCreate(postId) {
      let data = request.resource.data;
      return data.keys().hasOnly(['postId', 'authorId', 'authorSnapshot', 'text', 'createdAt'])
        && data.postId == postId
        && isValidAuthorSnapshot()
        && data.text is string
        && data.text.size() > 0
        && data.text.size() <= 1000
        && data.createdAt == request.time;
    }
    
    // Check if user is the post author
    function isPostAuthor() {
      return resource.data.authorId == request.auth.uid;
    }
    
    // posts/{postId}
    // Post metadata (PUBLIC READ, author write)
    match /posts/{postId} {
      // Anyone can read posts (even anonymous for discovery)
      allow read: if true;
      
      // Only authenticated users can create posts with valid author info
      allow create: if isAuthenticated()
        && (isValidPostCreate(postId) || isValidPostCreateUploading(postId));
      
      // Only the author can update their posts
      allow update: if isAuthenticated() && isPostAuthor()
        && (isValidPostUpdate(postId) || isValidPostUpdateUploading(postId));
      
      // Only the author can delete their posts
      allow delete: if isAuthenticated() && isPostAuthor();
    }
    
    // posts/{postId}/likes/{uid}
    // Post likes (source of truth for counting)
    match /posts/{postId}/likes/{uid} {
      // Likes are public for counts
      allow read: if true;
      
      // Only the user can like/unlike
      // Critical: Validate against BOTH path and auth
      allow create: if isOwner(uid) 
        && isValidPostLikeCreate(postId, uid)
        && request.resource.data.uid == request.auth.uid;  // Triple check
      
      allow delete: if isOwner(uid);
      
      // Update ONLY if critical fields don't change
      allow update: if isOwner(uid)
        && request.resource.data.uid == uid  // Must match path
        && request.resource.data.uid == request.auth.uid  // Must match auth
        && request.resource.data.postId == postId;  // Must match path
    }

    // posts/{postId}/comments/{commentId}
    match /posts/{postId}/comments/{commentId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidPostCommentCreate(postId);
      allow delete: if isAuthenticated() && resource.data.authorId == request.auth.uid;
      allow update: if false;
    }

    // ==================== Collaborations Collections ====================

    function isValidTagArray(tags) {
      return tags is list
        && tags.size() <= 6
        && (tags.size() == 0 || (tags[0] is string && tags[0].size() > 0 && tags[0].size() <= 40))
        && (tags.size() <= 1 || (tags[1] is string && tags[1].size() > 0 && tags[1].size() <= 40))
        && (tags.size() <= 2 || (tags[2] is string && tags[2].size() > 0 && tags[2].size() <= 40))
        && (tags.size() <= 3 || (tags[3] is string && tags[3].size() > 0 && tags[3].size() <= 40))
        && (tags.size() <= 4 || (tags[4] is string && tags[4].size() > 0 && tags[4].size() <= 40))
        && (tags.size() <= 5 || (tags[5] is string && tags[5].size() > 0 && tags[5].size() <= 40));
    }

    function isValidCollaborationData() {
      let data = request.resource.data;
      return data.title is string
        && data.title.size() > 0
        && data.title.size() <= 120
        && data.context is string
        && data.context.size() > 0
        && data.context.size() <= 120
        && data.seekingRole is string
        && data.seekingRole.size() > 0
        && data.seekingRole.size() <= 80
        && data.mode in ['virtual', 'presencial']
        && (data.location == null || (data.location is string && data.location.size() > 0 && data.location.size() <= 120))
        && data.level in ['principiante', 'intermedio', 'experto']
        && (data.topic == null || (data.topic is string && data.topic.size() > 0 && data.topic.size() <= 160))
        && isValidTagArray(data.tags)
        && data.status in ['open', 'closed'];
    }

    function isValidCollaborationCreate() {
      let data = request.resource.data;
      return data.keys().hasOnly([
          'title', 'context', 'seekingRole', 'mode', 'location', 'level', 'topic', 'tags',
          'authorId', 'authorSnapshot', 'status', 'createdAt', 'updatedAt'
        ])
        && isValidAuthorSnapshot()
        && isValidCollaborationData()
        && data.status == 'open'
        && data.createdAt == request.time
        && data.updatedAt == request.time;
    }

    function isValidCollaborationUpdate() {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly([
          'title', 'context', 'seekingRole', 'mode', 'location', 'level', 'topic', 'tags', 'status', 'updatedAt'
        ])
        && isValidAuthorSnapshot()
        && isValidCollaborationData()
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.updatedAt == request.time;
    }

    function isValidCollaborationRequestCreate() {
      let data = request.resource.data;
      let collab = get(/databases/$(database)/documents/collaborations/$(data.collaborationId));
      return data.keys().hasOnly([
          'collaborationId', 'collaborationTitle', 'fromUid', 'toUid', 'status', 'message',
          'fromUserName', 'fromUserPhoto', 'createdAt', 'updatedAt'
        ])
        && data.collaborationId is string
        && data.collaborationId.size() > 0
        && data.collaborationTitle is string
        && data.collaborationTitle.size() > 0
        && data.collaborationTitle.size() <= 140
        && data.fromUid == request.auth.uid
        && data.toUid is string
        && data.toUid.size() > 0
        && data.toUid != request.auth.uid
        && data.status == 'pending'
        && (data.message == null || (data.message is string && data.message.size() > 0 && data.message.size() <= 1000))
        && (data.fromUserName == null || (data.fromUserName is string && data.fromUserName.size() > 0 && data.fromUserName.size() <= 80))
        && (data.fromUserPhoto == null || data.fromUserPhoto is string)
        && data.createdAt == request.time
        && data.updatedAt == request.time
        && collab != null
        && collab.data != null
        && collab.data.authorId == data.toUid
        && collab.data.status == 'open';
    }

    function isValidCollaborationRequestUpdate() {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      return changed.hasOnly(['status', 'updatedAt'])
        && request.resource.data.status in ['accepted', 'rejected']
        && request.resource.data.updatedAt == request.time
        && request.resource.data.fromUid == resource.data.fromUid
        && request.resource.data.toUid == resource.data.toUid
        && request.resource.data.collaborationId == resource.data.collaborationId
        && request.resource.data.collaborationTitle == resource.data.collaborationTitle;
    }

    // collaborations/{collaborationId}
    // Collaboration posts (PUBLIC READ, author write)
    match /collaborations/{collaborationId} {
      allow read: if true;
      allow create: if isAuthenticated() && isValidCollaborationCreate();
      allow update: if isAuthenticated() && resource.data.authorId == request.auth.uid
        && isValidCollaborationUpdate();
      allow delete: if isAuthenticated() && resource.data.authorId == request.auth.uid;
    }

    // collaboration_requests/{requestId}
    // Requests to join a collaboration (private)
    match /collaboration_requests/{requestId} {
      allow read: if isAuthenticated()
        && (resource.data.fromUid == request.auth.uid || resource.data.toUid == request.auth.uid);
      allow create: if isAuthenticated() && isValidCollaborationRequestCreate();
      allow update: if isAuthenticated() && resource.data.toUid == request.auth.uid
        && isValidCollaborationRequestUpdate();
      allow delete: if isAuthenticated() && resource.data.fromUid == request.auth.uid;
    }
    
    // ==================== Messaging Collections ====================
    
    // Helper: Check if user can access conversation
    function isConversationParticipantData(convData, uid) {
      let hasType = convData != null && convData.keys().hasAny(['type']);
      return convData != null
        && (
          ((convData.type == "direct" || !hasType)
            && convData.memberIds is list
            && convData.memberIds.hasAny([uid]))
          || ((convData.type == "group" || !hasType)
            && convData.groupId is string
            && exists(/databases/$(database)/documents/groups/$(convData.groupId)/members/$(uid)))
        );
    }
    
    function canAccessConversationData(convData) {
      return isAuthenticated()
        && isConversationParticipantData(convData, request.auth.uid);
    }
    
    function canAccessConversation(conversationId) {
      let conv = get(/databases/$(database)/documents/conversations/$(conversationId));
      return isConversationParticipantData(conv.data, request.auth.uid);
    }

    function isValidDirectConversationRepair(conversationId) {
      let changed = request.resource.data.diff(resource.data).affectedKeys();
      let memberIds = request.resource.data.memberIds;
      return isAuthenticated()
        && conversationId.matches('^dm_.*$')
        && request.resource.data.type == 'direct'
        && memberIds is list
        && memberIds.size() == 2
        && memberIds[0] is string
        && memberIds[1] is string
        && memberIds.hasAny([request.auth.uid])
        && (
          conversationId == 'dm_' + memberIds[0] + '_' + memberIds[1]
          || conversationId == 'dm_' + memberIds[1] + '_' + memberIds[0]
        )
        && changed.hasOnly(['memberIds', 'type', 'updatedAt'])
        && request.resource.data.updatedAt == request.time
        && (!(resource.data.memberIds is list) || resource.data.memberIds.size() != 2 || resource.data.type != 'direct');
    }
    
    function canCreateConversationMember(conversationId, uid) {
      let conv = get(/databases/$(database)/documents/conversations/$(conversationId));
      let hasType = conv.data != null && conv.data.keys().hasAny(['type']);
      return conv.data != null
        && (
          ((conv.data.type == "direct" || !hasType)
            && conv.data.memberIds is list
            && conv.data.memberIds.hasAny([request.auth.uid])
            && conv.data.memberIds.hasAny([uid]))
          || ((conv.data.type == "group" || !hasType)
            && conv.data.groupId is string
            && request.auth.uid == uid
            && exists(/databases/$(database)/documents/groups/$(conv.data.groupId)/members/$(uid)))
        );
    }
    
    function isValidConversationMemberCreate(uid) {
      return request.resource.data.keys().hasAll(['uid', 'role', 'joinedAt', 'lastReadClientAt', 'lastReadAt', 'muted'])
        && request.resource.data.uid == uid
        && request.resource.data.role == 'member';
    }
    
    // conversations/{conversationId}
    match /conversations/{conversationId} {
      allow read: if canAccessConversationData(resource.data);
      
      // Restrict creation (no spam conversations)
      allow create: if isAuthenticated()
        && request.resource.data.type in ['direct', 'group']
        && (request.resource.data.type == 'direct' 
            ? request.resource.data.memberIds is list
              && request.resource.data.memberIds.size() == 2
              && request.resource.data.memberIds.hasAny([request.auth.uid])
            : request.resource.data.type == 'group' 
              && request.resource.data.groupId is string
              && exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid)));
      
      allow update: if (canAccessConversationData(resource.data)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'updatedAt']))
        || isValidDirectConversationRepair(conversationId);
      
      // Members (restrict updates)
      match /members/{uid} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow create: if isAuthenticated()
          && canCreateConversationMember(conversationId, uid)
          && isValidConversationMemberCreate(uid);
        allow update: if isAuthenticated() 
          && request.auth.uid == uid
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastReadClientAt', 'lastReadAt', 'muted'])
          && request.resource.data.role == resource.data.role;  // No self-promotion
        allow delete: if isAuthenticated() && request.auth.uid == uid;
      }
      
      // Messages
      match /messages/{messageId} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow create: if isAuthenticated() 
          && canAccessConversation(conversationId)
          && request.resource.data.senderId == request.auth.uid;
      }
      
      // Typing
      match /typing/{uid} {
        allow read: if isAuthenticated() && canAccessConversation(conversationId);
        allow write: if isAuthenticated() 
          && request.auth.uid == uid
          && canAccessConversation(conversationId);
      }
    }
    
    // ==================== Default Deny ====================
    
    // Deny all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
