rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ==================== Helper Functions ====================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the owner of the resource
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    // Validate membership structure (createdAt can be serverTimestamp)
    function isValidMembership() {
      return request.resource.data.keys().hasAll(['groupId', 'joinedAt'])
        && request.resource.data.groupId is string;
        // joinedAt validation omitted - serverTimestamp() is a sentinel, not a timestamp literal
    }
    
    // Validate like structure (createdAt can be serverTimestamp)
    function isValidLike() {
      return request.resource.data.keys().hasAll(['postId', 'createdAt'])
        && request.resource.data.postId is string;
        // createdAt validation omitted - serverTimestamp() is a sentinel
    }
    
    // Validate post like structure
    function isValidPostLike() {
      return request.resource.data.keys().hasAll(['uid', 'postId', 'createdAt'])
        && request.resource.data.uid is string
        && request.resource.data.postId is string;
    }
    
    // Validate group member structure
    function isValidGroupMember() {
      return request.resource.data.keys().hasAll(['uid', 'groupId', 'role', 'joinedAt'])
        && request.resource.data.uid is string
        && request.resource.data.groupId is string
        && request.resource.data.role is string;
    }
    
    // ==================== User Data Collections ====================
    
    // users/{uid}/memberships/{groupId}
    // User's joined groups (denormalized for fast reads)
    match /users/{uid}/memberships/{groupId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own memberships
      allow create: if isOwner(uid) && isValidMembership();
      allow delete: if isOwner(uid);
      
      // Allow update for idempotent writes with merge:true
      // Only allow if data doesn't change (same groupId)
      allow update: if isOwner(uid) 
        && request.resource.data.groupId == resource.data.groupId;
    }
    
    // users/{uid}/likes/{postId}
    // User's liked posts (denormalized for fast reads)
    match /users/{uid}/likes/{postId} {
      // Only owner can read (private)
      allow read: if isOwner(uid);
      
      // Only the user can write to their own likes
      allow create: if isOwner(uid) && isValidLike();
      allow delete: if isOwner(uid);
      
      // Allow update for idempotent writes
      allow update: if isOwner(uid)
        && request.resource.data.postId == resource.data.postId;
    }
    
    // users/{uid}/savedPosts/{postId}
    // User's saved posts (private)
    match /users/{uid}/savedPosts/{postId} {
      // Only the user can read their own saved posts
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved posts
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Allow update for idempotent writes
      allow update: if isOwner(uid);
    }
    
    // users/{uid}/savedCategories/{categoryId}
    // User's saved categories (private)
    match /users/{uid}/savedCategories/{categoryId} {
      // Only the user can read their own saved categories
      allow read: if isOwner(uid);
      
      // Only the user can write to their own saved categories
      allow create: if isOwner(uid);
      allow delete: if isOwner(uid);
      
      // Allow update for idempotent writes
      allow update: if isOwner(uid);
    }
    
    // ==================== Groups Collections ====================
    
    // groups/{groupId}
    // Group metadata (PUBLIC READ, admin write)
    match /groups/{groupId} {
      // Anyone can read groups (even anonymous users for discovery)
      allow read: if true;
      
      // For now, no one can create/update/delete groups
      // TODO: Add admin-only write when admin system is implemented
      allow write: if false;
    }
    
    // groups/{groupId}/members/{uid}
    // Group members (source of truth for counting)
    match /groups/{groupId}/members/{uid} {
      // Anyone can read members (public for member counts)
      allow read: if true;
      
      // Only the user can add/remove themselves as a member
      allow create: if isOwner(uid) && isValidGroupMember()
        && request.resource.data.uid == uid
        && request.resource.data.groupId == groupId
        && request.resource.data.role == 'member';
      
      allow delete: if isOwner(uid);
      
      // Allow update for idempotent writes with merge:true
      // Only allow if critical fields don't change
      allow update: if isOwner(uid)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.groupId == resource.data.groupId
        && request.resource.data.role == resource.data.role;
    }
    
    // ==================== Posts Collections ====================
    
    // posts/{postId}
    // Post metadata (PUBLIC READ, author write)
    match /posts/{postId} {
      // Anyone can read posts (even anonymous for discovery)
      allow read: if true;
      
      // For now, no one can create/update/delete posts
      // TODO: Add author-only write when posts system is implemented
      allow write: if false;
    }
    
    // posts/{postId}/likes/{uid}
    // Post likes (source of truth for counting)
    match /posts/{postId}/likes/{uid} {
      // Anyone can read likes (public for like counts)
      allow read: if true;
      
      // Only the user can like/unlike
      allow create: if isOwner(uid) && isValidPostLike()
        && request.resource.data.uid == uid
        && request.resource.data.postId == postId;
      
      allow delete: if isOwner(uid);
      
      // Allow update for idempotent writes with merge:true
      allow update: if isOwner(uid)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.postId == resource.data.postId;
    }
    
    // ==================== Default Deny ====================
    
    // Deny all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
